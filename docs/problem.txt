# Problem statement

It seems that I do want a create/resume/suspend mechanism.

Say I do have it. How do I implement non-blocking I/O on top of that?

Probably: code that needs to wait for I/O is ran in a coroutine. When it needs to wait for data, it yields. A separate I/O thread (?) will resume the coroutine when this data is available. It will be returned to the calling coroutine as the result of yield.

Yeah, so starting with the coroutine mechanism seems to be OK. But I want to get a clearer picture of how I will use it to implement non-blocking I/O.

Hm, and it seems that when this coroutine wants to read data it must schedule another coroutine, and this coroutine is special because it needs to make a kqueue call, so it must run in IO thread.

I want to make a stackful coroutine implementation in C++ and then build a non-blocking IO facility on top of that so that coroutines can wait for IO by suspending themselves. I will use a single thread for this, running an event loop that DOES block (i.e. does system calls to a non-blocking IO APIs). I want to implement something very simple with it (e.g. a VERY simple TCP server that echoes whatever you send it).

A dedicated I/O thread is needed because, if no I/O happens, the event loop will block. E.g. select WILL block to wait for some socket to be ready for I/O. kevent is similar in this regard.

How do I use asymmetric stackful coroutines for I/O?

I should probably do this:
1. User function (ran inside a coroutine) calls some other function
2. Somewhere in the call stack there's a function that needs to do I/O
3. It initiates I/O, e.g. makes a socket call with timeout=0, and yields a promise
4. The promise is yielded to an event loop that resumed the original coroutine. Event loop saves this promise somewhere (a reference to it?)
5. When promise is fulfilled, event loop resumes coroutine again giving it the fulfilled promise
6. Function takes promise result and returns it up the call stack to the original user function

Who fulfills the promise? It might be the event loop (e.g it repeatedly makes calls to kevent). It might be a separate I/O (netpoll) thread which repeatedly calls kevent and has a queue to consume new tasks and an output queue to fulfill promises.

Well, actually I don't know. I should probably think about it a little more.

I'm still not so fn sure about the API.

I think I should change it somewhat:
- on creation, I save args (so I accept both the function AND the args)
- I have Resume(), NO arguments. The first Resume will activate the coroutine and call the function, that's it.
- Pushing data back and forth between yielder and resumer is done via shared state, e.g. a coroutine may yield a reference to a Promise and dispatcher might fulfill the Promise and resume again. So NO data flow from resumer to yielder, only from yielder to resumer
- Non-empty returns are forbidden. Only yields.

OK then. What if I have a coroutine WITHOUT yield? Or maybe with yield, but it doesn't return anything. What would be the return value of Resume then?

Y must be default constructible it seems. Which is not good?

https://stackoverflow.com/questions/15537817/c-how-to-store-a-parameter-pack-as-a-variable

# Limitations

- I ONLY target macOS and M1 Macs. So I use the system interface provided by macOS and rely on the instruction set available on M1 Macs.
- I ONLY use one thread (really?)
- NO non-blocking I/O support. It can be added later.
- Stackful because this is more interesting
- So stackful, asymmetric (can be invoked & can suspend, suspend returns control to caller (??))

# Roadmap

- A coroutine facility
- An event loop with events coming from user input
- Do I/O WITHOUT non-blocking stuff (just use the socket API?). Example here: https://www.lua.org/pil/9.4.html. Socket API: https://man7.org/linux/man-pages/man2/recv.2.html
- A non-blocking IO facility in the event loop
- A simple TCP server

# How do I test?

A classical example: traversinf a binary tree in preorder. Wow, and this will be effectively non-recursive, right? Nah, it's going to be recursive, and that's kind of the point here. This is what stackful coroutines give us.

# How do I benchmark?

https://github.com/jamboree/co2
