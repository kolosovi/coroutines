# Problem statement

It seems that I do want a create/resume/suspend mechanism.

Say I do have it. How do I implement non-blocking I/O on top of that?

Probably: code that needs to wait for I/O is ran in a coroutine. When it needs to wait for data, it yields. A separate I/O thread (?) will resume the coroutine when this data is available. It will be returned to the calling coroutine as the result of yield.

Yeah, so starting with the coroutine mechanism seems to be OK. But I want to get a clearer picture of how I will use it to implement non-blocking I/O.

Hm, and it seems that when this coroutine wants to read data it must schedule another coroutine, and this coroutine is special because it needs to make a kqueue call, so it must run in IO thread.

I want to make a stackful coroutine implementation in C++ and then build a non-blocking IO facility on top of that so that coroutines can wait for IO by suspending themselves. I will use a single thread for this, running an event loop that DOES block (i.e. does system calls to a non-blocking IO APIs). I want to implement something very simple with it (e.g. a VERY simple TCP server that echoes whatever you send it).

A dedicated I/O thread is needed because, if no I/O happens, the event loop will block. E.g. select WILL block to wait for some socket to be ready for I/O. kevent is similar in this regard.

How do I use asymmetric stackful coroutines for I/O?

I should probably do this:
1. User function (ran inside a coroutine) calls some other function
2. Somewhere in the call stack there's a function that needs to do I/O
3. It initiates I/O, e.g. makes a socket call with timeout=0, and yields a promise
4. The promise is yielded to an event loop that resumed the original coroutine. Event loop saves this promise somewhere (a reference to it?)
5. When promise is fulfilled, event loop resumes coroutine again giving it the fulfilled promise
6. Function takes promise result and returns it up the call stack to the original user function

Who fulfills the promise? It might be the event loop (e.g it repeatedly makes calls to kevent). It might be a separate I/O (netpoll) thread which repeatedly calls kevent and has a queue to consume new tasks and an output queue to fulfill promises.

Well, actually I don't know. I should probably think about it a little more.

I'm still not so fn sure about the API.

I think I should change it somewhat:
- on creation, I save args (so I accept both the function AND the args)
- I have Resume(), NO arguments. The first Resume will activate the coroutine and call the function, that's it.
- Pushing data back and forth between yielder and resumer is done via shared state, e.g. a coroutine may yield a reference to a Promise and dispatcher might fulfill the Promise and resume again. So NO data flow from resumer to yielder, only from yielder to resumer
- Non-empty returns are forbidden. Only yields.

OK then. What if I have a coroutine WITHOUT yield? Or maybe with yield, but it doesn't return anything. What would be the return value of Resume then?

Y must be default constructible it seems. Which is not good?

https://stackoverflow.com/questions/15537817/c-how-to-store-a-parameter-pack-as-a-variable

```
52 sub	sp, sp, #48                     ; =48
53 stp	x20, x19, [sp, #16]             ; 16-byte Folded Spill
54 stp	x29, x30, [sp, #32]             ; 16-byte Folded Spill
55 add	x29, sp, #32                    ; =32
```

Quoting myself:
> For example, stp x20, x10, [sp, #16] stores the contents of register x20 into address sp + 16 and contents of x19 into address sp + 16 + 8 (each X register is 8 bytes wide).

Example:
```
    sp = 0x00080014 (524308)
sub sp, sp, #48
    sp = 0x0007ffe4 (524260)
stp	x20, x19, [sp, #16]
    Stores to range [sp+16, sp+31]
stp x29, x30, [sp, #32]
    Stores to range [sp+32, sp+47]
```

sp + 47 is initial sp - 1 byte. So anything that's stored at [sp] is not touched.
So full descending.

out-of-line assembly:
$ as -c -o return_42.o return_42.s
$ clang++ -v --std=c++11 -o a.out main.cpp return_42.o
$ ./a.out
42

stmfd instruction (store Full Descending, essentially a PUSH instruction)
https://developer.arm.com/documentation/ddi0406/b/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-instructions/STMDB---STMFD

Armv8 (A64) instruction set reference
https://developer.arm.com/documentation/ddi0602/2022-03/?lang=en

Quoting "Porting to Arm 64-bit" by Chris Shore:
> The load and store multiple instructions have been replaced with instructions which load and store pairs of 64-bit registers. These are used for stack operations as well, in place of the earlier PUSH and POP.

Also see https://stackoverflow.com/q/27095099

# Limitations

- I ONLY target macOS and M1 Macs. So I use the system interface provided by macOS and rely on the instruction set available on M1 Macs.
- I ONLY use one thread (really?)
- NO non-blocking I/O support. It can be added later.
- Stackful because this is more interesting
- So stackful, asymmetric (can be invoked & can suspend, suspend returns control to caller (??))

# Roadmap

- A coroutine facility
- An event loop with events coming from user input
- Do I/O WITHOUT non-blocking stuff (just use the socket API?). Example here: https://www.lua.org/pil/9.4.html. Socket API: https://man7.org/linux/man-pages/man2/recv.2.html
- A non-blocking IO facility in the event loop
- A simple TCP server

# How do I test?

A classical example: traversinf a binary tree in preorder. Wow, and this will be effectively non-recursive, right? Nah, it's going to be recursive, and that's kind of the point here. This is what stackful coroutines give us.

Another cool thing would be to implement non-recursive traversal with coroutines. ALTHOUGH it looks like it would waste A LOT of memory for no gain.

# How do I benchmark?

https://github.com/jamboree/co2

# Various notes

(lldb) p this
(coroutine::Coroutine<int> *) $2 = 0x000000016fdff110
(lldb) p caller_stack_top_ptr_
(coroutine_stack_t **) $3 = 0x000000010007d748
(lldb) p stack_top_
(coroutine_stack_t *) $4 = 0x00000001018101a8
(lldb) p &stack_top_
(coroutine_stack_t **) $5 = 0x000000016fdff148

## Debugging exception which is raised when coroutines are nested

Relevant test: Coroutine.MergeBinaryTrees (run with `./build/coroutine-api.test.cpp --gtest_filter=Coroutine.MergeBinaryTrees`).

Hypothesis:
1. in main, current_coroutine is null
2. i switch to merge coroutine, current_coroutine becomes &merge, merge status is kRunning
3. merge resumes lhs, current_coroutine becomes lhs. lhs status is kRunning
4. lhs yields, its status becomes kSuspended. current_coroutine is still lhs
5. merge yields. current_coroutine (=lhs) status is kSuspended, so we throw an exception

Debugging session.

I want to note:
- coroutine::Yield (`b /Users/ikolosov/work/repo/coroutines/include/coroutine/api.hpp:174`)
- coroutine::Resume (`b /Users/ikolosov/work/repo/coroutines/include/coroutine/api.hpp:166`)
- lhs & rhs addresses (`b /Users/ikolosov/work/repo/coroutines/src/coroutine/api.test.cpp:116`)

lldb debugging log below

```
-- set breakpoints
(lldb) b /Users/ikolosov/work/repo/coroutines/include/coroutine/api.hpp:174
Breakpoint 1: where = coroutine-api.test.cpp`void coroutine::Yield<int>(int) + 352 at api.hpp:174:9, address = 0x00000001000084c0
(lldb) b /Users/ikolosov/work/repo/coroutines/include/coroutine/api.hpp:166
Breakpoint 2: where = coroutine-api.test.cpp`std::__1::optional<int> coroutine::Resume<int>(coroutine::Coroutine<int>&) + 252 at api.hpp:166:5, address = 0x0000000100007d38
(lldb) b /Users/ikolosov/work/repo/coroutines/src/coroutine/api.test.cpp:116
Breakpoint 3: where = coroutine-api.test.cpp`Coroutine_TraverseBinaryTree2_Test::TestBody() + 1748 at api.test.cpp:116:10, address = 0x000000010000b6b0

-- stopped at Resume of merge coroutine, its address is 0x000000016fdfcd00, status is kSuspended which is expected
(lldb) run
Process 39092 launched: '/Users/ikolosov/work/repo/coroutines/build/coroutine-api.test.cpp' (arm64)
Running main() from /Users/ikolosov/work/repo/coroutines/build/_deps/googletest-src/googletest/src/gtest_main.cc
Note: Google Test filter = Coroutine.MergeBinaryTrees
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from Coroutine
[ RUN      ] Coroutine.MergeBinaryTrees
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
    frame #0: 0x0000000100007d38 coroutine-api.test.cpp`std::__1::optional<int> coroutine::Resume<int>(coro=0x000000016fdfcd00) at api.hpp:166:5
   163  // terminated rather than yielded, the return value is empty.
   164  template<typename Y>
   165  std::optional<Y> Resume(Coroutine<Y> &coro) {
-> 166      coro.Resume(&current_coroutine_stack_top);
   167      return coro.yield_value;
   168  }
   169
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) p coro
(coroutine::Coroutine<int>) $0 = {
  yield_value =  Has Value=false  {}
  status = kSuspended
  bound_fn_ = {
    __f_ = {
      __buf_ = (__lx = "\U00000010\xce\xdfoy\xffa<")
      __f_ = 0x0000000104600a40
    }
  }
  stack_ = 13744632839234567870 {
    __value_ = 0x0000000105200400
  }
  stack_top_ = 0x0000000105208300
  caller_stack_top_ptr_ = 0x0000000000000000
}
(lldb) p &coro
(coroutine::Coroutine<int> *) $1 = 0x000000016fdfcd00

-- stopped at Resume again.. Why? It seems I resume lhs, its address is 0x0000000105207520, its status is kSuspended as expected.
-- current_coroutine is merge coroutine, its status is kRunning as expected.
(lldb) c
Process 39092 resuming
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
    frame #0: 0x0000000100007d38 coroutine-api.test.cpp`std::__1::optional<int> coroutine::Resume<int>(coro=0x0000000105207520) at api.hpp:166:5
   163  // terminated rather than yielded, the return value is empty.
   164  template<typename Y>
   165  std::optional<Y> Resume(Coroutine<Y> &coro) {
-> 166      coro.Resume(&current_coroutine_stack_top);
   167      return coro.yield_value;
   168  }
   169
Target 0: (coroutine-api.test.cpp) stopped.

(lldb) p current_coroutine
(coroutine::Coroutine<int> *) $2 = 0x000000016fdfcd00
(lldb) p current_coroutine->status
(coroutine::Status) $7 = kRunning
(lldb) p &coro
(coroutine::Coroutine<int> *) $4 = 0x0000000105207520
(lldb) p coro.status
(coroutine::Status) $5 = kSuspended

-- stopped at yielding from lhs (current_coroutine). Its status is kRunnning which is expected.
(lldb) c
Process 39092 resuming
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000084c0 coroutine-api.test.cpp`void coroutine::Yield<int>(yield_value=1) at api.hpp:174:9
   171  // corresponding Resume.
   172  template<typename Y>
   173  void Yield(Y yield_value) {
-> 174      if (current_coroutine<Y> == nullptr) {
   175          throw AttemptToYieldFromOutsideACoroutineError();
   176      }
   177      current_coroutine<Y>->Yield(std::optional{yield_value});
Target 0: (coroutine-api.test.cpp) stopped.

(lldb) p current_coroutine
(coroutine::Coroutine<int> *) $8 = 0x0000000105207520

-- stopped at resuming.. who exactly? It seems that rhs. rhs address is 0x00000001052075d0, its status is kSuspended as expected.
(lldb) c
Process 39092 resuming
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
    frame #0: 0x0000000100007d38 coroutine-api.test.cpp`std::__1::optional<int> coroutine::Resume<int>(coro=0x00000001052075d0) at api.hpp:166:5
   163  // terminated rather than yielded, the return value is empty.
   164  template<typename Y>
   165  std::optional<Y> Resume(Coroutine<Y> &coro) {
-> 166      coro.Resume(&current_coroutine_stack_top);
   167      return coro.yield_value;
   168  }
   169
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) p &coro
(coroutine::Coroutine<int> *) $11 = 0x00000001052075d0
(lldb) p coro.status
(coroutine::Status) $12 = kSuspended

-- stopped at yielding from rhs. its status is kRunning which is expected
(lldb) c
Process 39092 resuming
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000084c0 coroutine-api.test.cpp`void coroutine::Yield<int>(yield_value=2) at api.hpp:174:9
   171  // corresponding Resume.
   172  template<typename Y>
   173  void Yield(Y yield_value) {
-> 174      if (current_coroutine<Y> == nullptr) {
   175          throw AttemptToYieldFromOutsideACoroutineError();
   176      }
   177      current_coroutine<Y>->Yield(std::optional{yield_value});
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) p current_coroutine
(coroutine::Coroutine<int> *) $13 = 0x00000001052075d0
(lldb) p current_coroutine->status
(coroutine::Status) $14 = kRunning

-- stopped at yielding from merge. BUT current_coroutine is still rhs because it isn't restored in Resume.
-- current_coroutine (=rhs) status is rightfully kSuspended.
-- tracing execution further, we reach the status check, which fails because kRunning is expected.
-- An exception is then thrown.
(lldb) c
Process 39092 resuming
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00000001000084c0 coroutine-api.test.cpp`void coroutine::Yield<int>(yield_value=1) at api.hpp:174:9
   171  // corresponding Resume.
   172  template<typename Y>
   173  void Yield(Y yield_value) {
-> 174      if (current_coroutine<Y> == nullptr) {
   175          throw AttemptToYieldFromOutsideACoroutineError();
   176      }
   177      current_coroutine<Y>->Yield(std::optional{yield_value});
Target 0: (coroutine-api.test.cpp) stopped.

(lldb) p current_coroutine
(coroutine::Coroutine<int> *) $15 = 0x00000001052075d0
(lldb) p current_coroutine->status
(coroutine::Status) $16 = kSuspended
(lldb) s
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step in
    frame #0: 0x000000010000853c coroutine-api.test.cpp`void coroutine::Yield<int>(yield_value=1) at api.hpp:177:5
   174      if (current_coroutine<Y> == nullptr) {
   175          throw AttemptToYieldFromOutsideACoroutineError();
   176      }
-> 177      current_coroutine<Y>->Yield(std::optional{yield_value});
   178  }
   179
   180  }
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) s
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step in
    frame #0: 0x0000000100016820 coroutine-api.test.cpp`coroutine::Coroutine<int>::Yield(this=0x00000001052075d0, yield_value= Has Value=true ) at api.hpp:119:35
   116      }
   117
   118      void Yield(std::optional<Y> yield_value) {
-> 119          yield(Status::kSuspended, yield_value);
   120      }
   121
   122      void Call() {
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) s
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step in
    frame #0: 0x0000000100016d50 coroutine-api.test.cpp`coroutine::Coroutine<int>::yield(this=0x00000001052075d0, new_status=kSuspended, yield_value= Has Value=true ) at api.hpp:146:13
   143      static const int kLinkRegisterOffset = 0x98 / sizeof(coroutine_stack_t);
   144
   145      void yield(Status new_status, std::optional<Y> yield_value) {
-> 146          if (status != Status::kRunning) {
   147              throw StatusViolationError::New(status, {Status::kRunning});
   148          }
   149          status = new_status;
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) s
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step in
    frame #0: 0x0000000100016da0 coroutine-api.test.cpp`coroutine::Coroutine<int>::yield(this=0x00000001052075d0, new_status=kSuspended, yield_value= Has Value=true ) at api.hpp:147:13
   144
   145      void yield(Status new_status, std::optional<Y> yield_value) {
   146          if (status != Status::kRunning) {
-> 147              throw StatusViolationError::New(status, {Status::kRunning});
   148          }
   149          status = new_status;
   150          this->yield_value = yield_value;
Target 0: (coroutine-api.test.cpp) stopped.
(lldb) c
Process 39092 resuming
==39092==WARNING: ASan is ignoring requested __asan_handle_no_return: stack type: default top: 0x00016fe00000; bottom 0x000105200000; size: 0x00006ac00000 (1790967808)
False positive error reports may follow
For details see https://github.com/google/sanitizers/issues/189
Process 39092 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000195e4dd94 libunwind.dylib`libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm64>::step() + 600
libunwind.dylib`libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm64>::step:
->  0x195e4dd94 <+600>: ldr    x9, [x10]
    0x195e4dd98 <+604>: str    x9, [x19, #0xf8]
    0x195e4dd9c <+608>: add    x9, x10, #0x10            ; =0x10
    0x195e4dda0 <+612>: str    x9, [x19, #0x108]
Target 0: (coroutine-api.test.cpp) stopped.
```

I applied a fix (saving current_coroutine into a local variable and restoring it)

```
-- set breakpoint in Coroutine::Resume
(lldb) b /Users/ikolosov/work/repo/coroutines/include/coroutine/api.hpp:115

(lldb) run
Process 41232 launched: '/Users/ikolosov/work/repo/coroutines/build/coroutine-api.test.cpp' (arm64)
Running main() from /Users/ikolosov/work/repo/coroutines/build/_deps/googletest-src/googletest/src/gtest_main.cc
Note: Google Test filter = Coroutine.MergeBinaryTrees
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from Coroutine
[ RUN      ] Coroutine.MergeBinaryTrees
Process 41232 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100038bd0 coroutine-api.test.cpp`coroutine::Coroutine<int>::Resume(this=0x000000016fdfcd00, caller_stack_top_ptr=0x000000010032aa00) at api.hpp:115:22
   112          caller_stack_top_ptr_ = caller_stack_top_ptr;
   113          status = Status::kRunning;
   114          current_coroutine<Y> = this;
-> 115          switch_stack(caller_stack_top_ptr_, &stack_top_);
   116      }
   117
   118      void Yield(std::optional<Y> yield_value) {
Target 0: (coroutine-api.test.cpp) stopped.

(lldb) p caller_stack_top_ptr_
(coroutine_stack_t **) $0 = 0x000000010032aa00
(lldb) p stack_top_
(coroutine_stack_t *) $1 = 0x0000000105208300
(lldb) p current_coroutine
(coroutine::Coroutine<int> *) $2 = 0x000000016fdfcd00

place a breakpoint on Yield w/ condition that this = 0x000000016fdfcd00
```

hmmm
