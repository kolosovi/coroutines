# Problem statement

It seems that I do want a create/resume/suspend mechanism.

Say I do have it. How do I implement non-blocking I/O on top of that?

Probably: code that needs to wait for I/O is ran in a coroutine. When it needs to wait for data, it yields. A separate I/O thread (?) will resume the coroutine when this data is available. It will be returned to the calling coroutine as the result of yield.

Yeah, so starting with the coroutine mechanism seems to be OK. But I want to get a clearer picture of how I will use it to implement non-blocking I/O.

Hm, and it seems that when this coroutine wants to read data it must schedule another coroutine, and this coroutine is special because it needs to make a kqueue call, so it must run in IO thread.

I want to make a stackful coroutine implementation in C++ and then build a non-blocking IO facility on top of that so that coroutines can wait for IO by suspending themselves. I will use a single thread for this, running an event loop that DOES block (i.e. does system calls to a non-blocking IO APIs). I want to implement something very simple with it (e.g. a VERY simple TCP server that echoes whatever you send it).

A dedicated I/O thread is needed because, if no I/O happens, the event loop will block. E.g. select WILL block to wait for some socket to be ready for I/O. kevent is similar in this regard.

How do I use asymmetric stackful coroutines for I/O?

I should probably do this:
1. User function (ran inside a coroutine) calls some other function
2. Somewhere in the call stack there's a function that needs to do I/O
3. It initiates I/O, e.g. makes a socket call with timeout=0, and yields a promise
4. The promise is yielded to an event loop that resumed the original coroutine. Event loop saves this promise somewhere (a reference to it?)
5. When promise is fulfilled, event loop resumes coroutine again giving it the fulfilled promise
6. Function takes promise result and returns it up the call stack to the original user function

Who fulfills the promise? It might be the event loop (e.g it repeatedly makes calls to kevent). It might be a separate I/O (netpoll) thread which repeatedly calls kevent and has a queue to consume new tasks and an output queue to fulfill promises.

Well, actually I don't know. I should probably think about it a little more.

I'm still not so fn sure about the API.

I think I should change it somewhat:
- on creation, I save args (so I accept both the function AND the args)
- I have Resume(), NO arguments. The first Resume will activate the coroutine and call the function, that's it.
- Pushing data back and forth between yielder and resumer is done via shared state, e.g. a coroutine may yield a reference to a Promise and dispatcher might fulfill the Promise and resume again. So NO data flow from resumer to yielder, only from yielder to resumer
- Non-empty returns are forbidden. Only yields.

OK then. What if I have a coroutine WITHOUT yield? Or maybe with yield, but it doesn't return anything. What would be the return value of Resume then?

Y must be default constructible it seems. Which is not good?

https://stackoverflow.com/questions/15537817/c-how-to-store-a-parameter-pack-as-a-variable

```
52 sub	sp, sp, #48                     ; =48
53 stp	x20, x19, [sp, #16]             ; 16-byte Folded Spill
54 stp	x29, x30, [sp, #32]             ; 16-byte Folded Spill
55 add	x29, sp, #32                    ; =32
```

Quoting myself:
> For example, stp x20, x10, [sp, #16] stores the contents of register x20 into address sp + 16 and contents of x19 into address sp + 16 + 8 (each X register is 8 bytes wide).

Example:
```
    sp = 0x00080014 (524308)
sub sp, sp, #48
    sp = 0x0007ffe4 (524260)
stp	x20, x19, [sp, #16]
    Stores to range [sp+16, sp+31]
stp x29, x30, [sp, #32]
    Stores to range [sp+32, sp+47]
```

sp + 47 is initial sp - 1 byte. So anything that's stored at [sp] is not touched.
So full descending.

out-of-line assembly:
$ as -c -o return_42.o return_42.s
$ clang++ -v --std=c++11 -o a.out main.cpp return_42.o
$ ./a.out
42

stmfd instruction (store Full Descending, essentially a PUSH instruction)
https://developer.arm.com/documentation/ddi0406/b/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-instructions/STMDB---STMFD

Armv8 (A64) instruction set reference
https://developer.arm.com/documentation/ddi0602/2022-03/?lang=en

Quoting "Porting to Arm 64-bit" by Chris Shore:
> The load and store multiple instructions have been replaced with instructions which load and store pairs of 64-bit registers. These are used for stack operations as well, in place of the earlier PUSH and POP.

Also see https://stackoverflow.com/q/27095099

# Limitations

- I ONLY target macOS and M1 Macs. So I use the system interface provided by macOS and rely on the instruction set available on M1 Macs.
- I ONLY use one thread (really?)
- NO non-blocking I/O support. It can be added later.
- Stackful because this is more interesting
- So stackful, asymmetric (can be invoked & can suspend, suspend returns control to caller (??))

# Roadmap

- A coroutine facility
- An event loop with events coming from user input
- Do I/O WITHOUT non-blocking stuff (just use the socket API?). Example here: https://www.lua.org/pil/9.4.html. Socket API: https://man7.org/linux/man-pages/man2/recv.2.html
- A non-blocking IO facility in the event loop
- A simple TCP server

# How do I test?

A classical example: traversinf a binary tree in preorder. Wow, and this will be effectively non-recursive, right? Nah, it's going to be recursive, and that's kind of the point here. This is what stackful coroutines give us.

Another cool thing would be to implement non-recursive traversal with coroutines. ALTHOUGH it looks like it would waste A LOT of memory for no gain.

# How do I benchmark?

https://github.com/jamboree/co2

(lldb) p this
(coroutine::Coroutine<int> *) $2 = 0x000000016fdff110
(lldb) p caller_stack_top_ptr_
(coroutine_stack_t **) $3 = 0x000000010007d748
(lldb) p stack_top_
(coroutine_stack_t *) $4 = 0x00000001018101a8
(lldb) p &stack_top_
(coroutine_stack_t **) $5 = 0x000000016fdff148
